# Java to Kotlin

This is a simple project to convert Java code to Kotlin code.

1. 소개

   1.1 프로그래밍 언어의 결

   1.2 코틀린의 결

   1.3 코틀린으로 리펙터링하기

   1.3.1 리펙터링 원칙

   1.3.2 테스트 커버리지가 좋다고 가정한다.

   1.3.3 git bisect를 고려해 커밋한다.

   1.4 어떤 코드를 변경할까?

   1.5 시작하기

2. 자바 프로젝트에서 코틀린 프로젝트로

   2.1 전략

   2.2 코틀린 지원을 자바 빌드에 추가하기

   2.3 다음으로 나아가기

3. 자바 클래스에서 코틀린 클래스로

   3.1 간단한 값 타입

   3.2 데이터 클래스의 한계

   3.3 다음으로 나아가기

4. 옵셔널에서 널이 될 수 있는 타입으로

   4.1 없음을 표현하기

   4.2 옵셔널에서 널 가능성으로 리펙터링하기

   4.3 코틀린다운 코드로 리펙터링하기

   4.4 다음으로 나아가기

5. 빈에서 값으로

   5.1 빈

   5.2 값

   5.3 값을 선호해야만 하는 이유는 무엇인가?

   5.4 빈을 값으로 리펙터링하기

   5.5 다음으로 나아가기

6. 자바에서 코틀린 컬렉션으로

   6.1 자바 컬렉션

   6.2 코틀린 컬렉션

   6.3 자바에서 코틀린 컬렉션으로 리펙터링하기

   6.3.1 자바 코드 고치기

   6.3.2 코틀린으로 변환하기

   6.4 다음으로 나아가기

7. 동작에서 계산으로

   7.1 함수

   7.2 계산

   7.3 동작

   7.4 왜 계산과 동작에 신경 쓰는가?

   7.5 왜 계산을 선호하는가?

   7.6 동작을 계산으로 리펙터링하기

   7.6.1 기존 코드

   7.6.2 더 나은 설계

   7.6.3 마지막 단계

   7.7 다음으로 나아가기

8. 정적 메서드에서 최상위 함수로

   8.1 자바 정적 멤버

   8.2 코틀린 최상위 함수로 리펙터링하기

   8.3 정적 메서드를 최상위 함수로 리펙터링하기

   8.4 최상위로 옮기기

   8.5 코틀린답게 다듬기

   8.6 다음으로 나아가기

9. 다중식 함수에서 단일식 함수로

   9.1 테이크 1: 인라이닝

   9.2 테이크 2: 새 함수 도입하기

   9.3 테이크 3: let

   9.4 테이크 4: 한 걸음 물러서기

   9.5 다음으로 나아가기

10. 함수에서 확장 함수로

    10.1 함수와 메서드

    10.2 확장 함수

    10.3 확장 함수의 타입과 함수의 타입

    10.4 확장 프로퍼티

    10.5 변환

    10.6 널이 될 수 있는 파라미터

    10.7 널이 될 수 있는 수신 객체

    10.8 제네릭스

    10.9 확장 함수를 메서드로 정의하기

    10.10 확장 함수로 리펙터링하기

    10.11 다음으로 나아가기

11. 메서드에서 프로퍼티로

    11.1 필드, 접근자, 프로퍼티

    11.2 어떻게 선택해야 할까?

    11.3 가변 프로퍼티

    11.4 프로퍼티로 리펙터링하기

    11.5 다음으로 나아가기

12. 함수에서 연산자로

    12.1 토대가 되는 클래스: Money

    12.2 사용자 정의 연산자 추가

    12.3 기존 코틀린 코드에서 정의한 연산자 호출하기

    12.4 기존 자바 클래스를 위한 연산자

    12.5 값을 표현하는 관습

    12.6 다음으로 나아가기

13. 스트림에서 이터러블이나 시퀀스로

    13.1 자바 스트림

    13.2 코틀린 이터러블

    13.3 코틀린 시퀀스

    13.4 다중 이터레이션

    13.5 스트림, 이터러블, 시퀀스 사이에 선택하기

    13.6 대수적 변환

    13.7 스트림에서 이터러블이나 시퀀스로 리펙터링하기

    13.7.1 이터러블을 먼저 고려하기

    13.7.2 그 다음 시퀀스로 변환하기

    13.7.3 파이프라인 일부를 추출하기

    13.7.4 마지막 정리

    13.8 다음으로 나아가기

14. 누적시키는 객체에서 변환으로

    14.1 누적기 파라미터를 사용해 계산하기

    14.2 불변 데이터에 작용하는 함수로 리펙터링하기

    14.3 한 번 더 해보자

    14.4 발견한 추상화를 더 풍성하게 만들기

    14.5 다음으로 나아가기

15. 캡슐화한 컬렉션에서 타입 별명으로

    15.1 도메인 컬렉션 합성하기

    15.2 다른 프로퍼티가 있는 컬렉션

    15.3 캡슐화된 컬렉션 리펙터링하기

    15.3.1 연산을 확장으로 변환하기

    15.3.2 타입 별명 치환

    15.3.3 다른 프로퍼티와 함께 있는 컬렉션 리펙터링하기

    15.4 다음으로 나아가기

16. 인터페이스에서 함수로

    16.1 객체 지향 캡슐화

    16.2 함수형 캡슐화

    16.3 자바의 함수 타입

    16.4 믹스 앤드 매치

    16.5 여러 접근 방법의 비교

    16.6 결합

    16.7 객체 지향인가 함수형인가?

    16.8 자바의 레거시

    16.9 추적 가능성

    16.10 인터페이스에서 함수로 리펙터링하기

    16.10.1 함수 도입하기

    16.11 다음으로 나아가기

17. 목에서 맵으로

    17.1 목을 맵으로 대체하기

    17.2 그렇지만 실제 목에서 벗어났는가?

    17.3 다음으로 나아가기

18. 열린 클래스에서 봉인된 클래스로

    18.1 다형성을 쓸까 봉인된 클래스를 쓸까?

    18.2 인터페이스를 봉인된 클래스로 변환하기

    18.3 다음으로 나아가기

19. 예외 던지기에서 값 반환으로

    19.1 예외 이전의 오류 처리

    19.2 예외를 사용한 오류 처리

    19.3 자바와 체크 예외

    19.4 코틀린과 예외

    19.5 예외를 넘어서: 함수형 오류 처리

    19.6 코틀린의 오류 처리

    19.7 예외를 오류로 리펙터링하기

    19.7.1 변환 전략

    19.7.2 맨 밑에서 시작하기

    19.7.3 축소

    19.7.4 밖으로 나가기

    19.8 더 수정하기

    19.9 계층

    19.10 다음으로 나아가기

20. I/O 수행에서 데이터 전달로

    20.1 테스트에 귀 기울이기

    20.2 I/O에서 데이터로

    20.3 효율적인 쓰기

    20.4 효과적인 읽기

    20.5 다음으로 나아가기

21. 예외에서 값으로

    21.1 잘못된 원인 파악하기

    21.2 오류 표현하기

    21.3 I/O를 어떻게 처리할까?

    21.4 다음으로 나아가기

22. 클래스에서 함수로

    22.1 인수 테스트

    22.2 단위 테스트

    22.3 헤더

    22.4 다른 필드 구분자

    22.5 시퀀스

    22.6 파일 읽기

    22.7 커먼즈 CSV와 비교하기

    22.8 다음으로 나아가기

23. 여행은 계속된다

    23.1 결

    23.2 함수형 사고

    23.3 단순한 설계

    23.4 함수형 프로그래밍과 텍스트를 통한 추론

    23.5 리펙터링

    23.6 리펙터링과 함수형 사고